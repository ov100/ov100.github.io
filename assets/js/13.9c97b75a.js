(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{370:function(v,t,r){"use strict";r.r(t);var _=r(25),a=Object(_.a)({},(function(){var v=this,t=v.$createElement,r=v._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("h1",{attrs:{id:"spring"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[v._v("#")]),v._v(" Spring")]),v._v(" "),r("h2",{attrs:{id:"ioc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ioc"}},[v._v("#")]),v._v(" IoC")]),v._v(" "),r("p",[v._v("IoC（Inverse of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spirng 特有，在其他语言中也有应用。")]),v._v(" "),r("ul",[r("li",[r("strong",[v._v("控制")]),v._v(" ：指的是对象创建（实例化、管理）的权力")]),v._v(" "),r("li",[r("strong",[v._v("反转")]),v._v(" ：控制权交给外部环境（Spring 框架、IoC 容器）")])]),v._v(" "),r("h2",{attrs:{id:"aop"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aop"}},[v._v("#")]),v._v(" AOP")]),v._v(" "),r("ul",[r("li",[r("strong",[v._v("AOP(Aspect-Oriented Programming")]),v._v(":面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。")]),v._v(" "),r("li",[v._v("Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：")])]),v._v(" "),r("p",[r("img",{attrs:{src:"/images/framework/spring/aop.jpeg",alt:""}})]),v._v(" "),r("ul",[r("li",[r("p",[r("strong",[v._v("JDK动态代理")]),v._v("是基于反射机制,生成一个实现代理接口的匿名类,然后重写方法,实现方法的增强.\n它生成类的速度很快,但是运行时因为是基于反射,调用后续的类操作会很慢.\n而且他是只能针对接口编程的.")])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("CGLIB动态代理")]),v._v("是基于继承机制,继承被代理类,所以方法不要声明为final,然后重写父类方法达到增强了类的作用.\n它底层是基于asm第三方框架,是对代理对象类的class文件加载进来,通过修改其字节码生成子类来处理.\n生成类的速度慢,但是后续执行类的操作时候很快.")])])]),v._v(" "),r("blockquote",[r("p",[v._v("如果目标对象实现了接口,默认情况下是采用JDK动态实现AOP\n如果目标对象没有实现接口,必须采用CGLIB库.")])]),v._v(" "),r("h2",{attrs:{id:"反射"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#反射"}},[v._v("#")]),v._v(" 反射")]),v._v(" "),r("p",[r("strong",[v._v("什么是反射")])]),v._v(" "),r("ul",[r("li",[v._v("可以在运行时期动态获取任何类的信息,如属性和方法.")]),v._v(" "),r("li",[v._v("可以在运行时期动态调用任何类的属性和方法.")]),v._v(" "),r("li",[v._v("动态调用获取信息和动态调用类的方法叫做反射.")])]),v._v(" "),r("p",[r("strong",[v._v("优点")])]),v._v(" "),r("ul",[r("li",[v._v("反射可以动态访问和调用类的方法和属性,而不局限于硬编码.提高了程序的扩展性,降低耦合度.允许程序创建可控制任何对象.")])]),v._v(" "),r("p",[r("strong",[v._v("缺点")])]),v._v(" "),r("ul",[r("li",[v._v("性能问题")]),v._v(" "),r("li",[v._v("内部暴露问题,因为可以访问私有变量,出现问题")])]),v._v(" "),r("p",[r("strong",[v._v("问题1")]),v._v("：Java反射机制可以动态修改实例中final修饰的成员变量吗？")]),v._v(" "),r("ul",[r("li",[v._v("回答是分两种情况的。")]),v._v(" "),r("li",[v._v("当final修饰的成员变量在"),r("strong",[v._v("定义的时候就初始化了值")]),v._v("，那么java反射机制就已经不能动态修改它的值了。")]),v._v(" "),r("li",[v._v("当final修饰的成员变量在定义的时候并"),r("strong",[v._v("没有初始化值")]),v._v("的话，那么就还能通过java反射机制来动态修改它的值。")])]),v._v(" "),r("h2",{attrs:{id:"拦截器interceptor和过滤器filter的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#拦截器interceptor和过滤器filter的区别"}},[v._v("#")]),v._v(" 拦截器Interceptor和过滤器Filter的区别")]),v._v(" "),r("ul",[r("li",[v._v("拦截器是基于java的反射机制的，而过滤器是基于函数回调。")]),v._v(" "),r("li",[v._v("拦截器不依赖与servlet容器，过滤器依赖与servlet容器。")]),v._v(" "),r("li",[v._v("拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。")]),v._v(" "),r("li",[v._v("拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。")]),v._v(" "),r("li",[v._v("在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。")]),v._v(" "),r("li",[v._v("拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。")])])])}),[],!1,null,null,null);t.default=a.exports}}]);