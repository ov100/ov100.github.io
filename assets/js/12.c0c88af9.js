(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{370:function(r,t,a){"use strict";a.r(t);var s=a(25),i=Object(s.a)({},(function(){var r=this,t=r.$createElement,a=r._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h1",{attrs:{id:"spring-ioc-aop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-ioc-aop"}},[r._v("#")]),r._v(" Spring IOC & AOP")]),r._v(" "),a("h2",{attrs:{id:"什么是ioc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是ioc"}},[r._v("#")]),r._v(" 什么是IoC")]),r._v(" "),a("p",[r._v("IoC（Inverse of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spirng 特有，在其他语言中也有应用。")]),r._v(" "),a("h2",{attrs:{id:"为什么叫控制反转"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么叫控制反转"}},[r._v("#")]),r._v(" 为什么叫控制反转？")]),r._v(" "),a("ul",[a("li",[a("strong",[r._v("控制")]),r._v(" ：指的是对象创建（实例化、管理）的权力")]),r._v(" "),a("li",[a("strong",[r._v("反转")]),r._v(" ：控制权交给外部环境（Spring 框架、IoC 容器）")])]),r._v(" "),a("h2",{attrs:{id:"什么是ioc-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是ioc-2"}},[r._v("#")]),r._v(" 什么是IoC")]),r._v(" "),a("ul",[a("li",[a("strong",[r._v("AOP(Aspect-Oriented Programming")]),r._v(":面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。")]),r._v(" "),a("li",[r._v("Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：")])]),r._v(" "),a("p",[a("img",{attrs:{src:"/images/framework/spring/aop.jpeg",alt:""}})])])}),[],!1,null,null,null);t.default=i.exports}}]);